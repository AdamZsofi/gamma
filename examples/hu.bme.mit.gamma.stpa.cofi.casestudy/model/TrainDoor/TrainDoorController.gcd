package traindoorcontrol

import "Interface/Interface.gcd"

@OrthogonalRegionSchedule = sequential
@TransitionPriority = order-based
statechart TrainDoorController [
	port ControlActions : provides ControlActions
	port FeedbackDoorState : requires FeedbackDoorState
	port FeedbackPresence : requires FeedbackPresence
	port ExternalCommunication : requires ExternalCommunication
] {
	region DoorStateRegion {
		initial InitialDoorState
		state Closing
		state Closed
		state Opening
		state Open
	}
	transition from InitialDoorState to Closed
	transition from Closed to Opening when FeedbackDoorState.opening
	transition from Opening to Open when FeedbackDoorState.open
	transition from Opening to Closing when FeedbackDoorState.closing
	transition from Open to Closing when FeedbackDoorState.closing
	transition from Closing to Closed when FeedbackDoorState.closed
	transition from Closing to Opening when FeedbackDoorState.opening
//	// Need these to allow for measuring time since state change
//	region PresenceRegion {
//		initial InitialPresence
//		state NoneInDoorway
//		state PersonInDoorway
//	}
//	transition from InitialPresence to NoneInDoorway
//	transition from NoneInDoorway to PersonInDoorway when FeedbackPresence.presence
//	transition from PersonInDoorway to NoneInDoorway when FeedbackPresence.none
//	
//	region EmergencyRegion {
//		initial InitialEmergency
//		state NoEmergency
//		state Emergency
//	}
//	transition from InitialEmergency to NoEmergency
//	transition from NoEmergency to Emergency when ExternalCommunication.emergency
//	transition from Emergency to NoEmergency when ExternalCommunication.noEmergency
//	
//	region AlignmentRegion {
//		initial InitialAlignment
//		state Alignment
//		state NoAlignment
//	}
//	transition from InitialAlignment to Alignment
//	transition from Alignment to NoAlignment when ExternalCommunication.noAlignment
//	transition from NoAlignment to Alignment when ExternalCommunication.alignment
//	
//	region MovementRegion {
//		initial InitialMovement
//		state NoMovement
//		state Movement
//	}
//	transition from InitialMovement to NoMovement
//	transition from NoMovement to Movement when ExternalCommunication.movement
//	transition from Movement to NoMovement when ExternalCommunication.noMovement
//	
//	region ControlRegion {
//		initial InitialControl
//		state Control
//		merge OpenDoor
//		merge CloseDoor
//	}
//	transition from InitialControl to Control
//	
//	transition from Control to OpenDoor when cycle [
//			!(in-state(DoorStateRegion.Opening) or in-state(DoorStateRegion.Open)) and // Needed?
//			in-state(EmergencyRegion.Emergency)]
//	transition from Control to OpenDoor when cycle [
//			!(in-state(DoorStateRegion.Opening) or in-state(DoorStateRegion.Open)) and // Needed?
//			in-state(PresenceRegion.PersonInDoorway)]
//	transition from Control to Control when cycle [  // Self-loop: needed?
//			in-state(MovementRegion.Movement)]
//	transition from Control to Control when cycle [  // Self-loop: needed?
//			in-state(AlignmentRegion.NoAlignment)]
//	
//	transition from OpenDoor to Control / raise ControlActions.openDoor;
//	
//	transition from Control to Control when cycle [ // Self-loop: conflict with open
//			in-state(PresenceRegion.PersonInDoorway)] 
//	transition from Control to Control when cycle [ // Self-loop: conflict with open
//			in-state(EmergencyRegion.Emergency)]
//	transition from Control to CloseDoor when cycle [ // Else we close
//			!(in-state(DoorStateRegion.Closing) or in-state(DoorStateRegion.Closed))] // Needed?
//	
//	transition from CloseDoor to Control / raise ControlActions.closeDoor;
	
//	region DoorActuatorRegion {
//		initial InitialDoorActuator
//		state IdleDoorActuator
//	}
//	transition from InitialDoorActuator to IdleDoorActuator
//	
//////////////////////////
//
//	region DoorStateSensorRegion {
//		initial InitialDoorStateSensor
//		state IdleDoorStateSensor
//	}
//	transition from InitialDoorStateSensor to IdleDoorStateSensor
//	
//	region PresenceSensorRegion {
//		initial InitialPresenceSensor
//		state IdlePresenceSensor
//	}
//	transition from InitialPresenceSensor to IdlePresenceSensor
//	
//	region DoorRegion {
//		initial InitialDoor
//		state IdleDoor
//	}
//	transition from InitialDoor to IdleDoor
	
}
