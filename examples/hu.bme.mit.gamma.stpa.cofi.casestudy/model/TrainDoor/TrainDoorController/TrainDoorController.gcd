package traindoorcontrol

import "Interface/Interface.gcd"

//const TOO_LATE_CLOSED_WHEN_UNALIGNED : integer := 5
const OPEN_TIME : integer := 10

@OrthogonalRegionSchedule = sequential
@TransitionPriority = order-based
statechart TrainDoorController [
	port ControlActions : provides ControlActions
	port FeedbackDoorState : requires FeedbackDoorState
	port FeedbackPresence : requires FeedbackPresence
	port ExternalCommunication : requires ExternalCommunication
] {
//	timeout tooLateCloseWhenUnaligned
//	var tooLateClosedWhenUnaligned : boolean := false
//	var closedSentWhenUnaligned : boolean := false
	timeout openTime
	
	region DoorStateRegion {
		initial InitialDoorState
		state Closing
		state Closed
		state Opening
		state Open {
			entry / set openTime := OPEN_TIME s;
		}
	}
	transition from InitialDoorState to Closed
	transition from Closed to Opening when FeedbackDoorState.feedback [FeedbackDoorState.feedback::doorState == DoorState::OPENING]
	transition from Opening to Open when FeedbackDoorState.feedback [FeedbackDoorState.feedback::doorState == DoorState::OPEN]
	transition from Opening to Closing when FeedbackDoorState.feedback [FeedbackDoorState.feedback::doorState == DoorState::CLOSING]
	transition from Open to Closing when FeedbackDoorState.feedback [FeedbackDoorState.feedback::doorState == DoorState::CLOSING]
	transition from Closing to Closed when FeedbackDoorState.feedback [FeedbackDoorState.feedback::doorState == DoorState::CLOSED]
	transition from Closing to Opening when FeedbackDoorState.feedback [FeedbackDoorState.feedback::doorState == DoorState::OPENING]
	// Need these to allow for measuring time upon state change
	region PresenceRegion {
		initial InitialPresence
		state NoneInDoorway
		state PersonInDoorway
	}
	transition from InitialPresence to NoneInDoorway
	transition from NoneInDoorway to PersonInDoorway when FeedbackPresence.feedback [FeedbackPresence.feedback::isPresent]
	transition from PersonInDoorway to NoneInDoorway when FeedbackPresence.feedback [!FeedbackPresence.feedback::isPresent]
	
	region EmergencyRegion {
		initial InitialEmergency
		state NoEmergency
		state Emergency
	}
	transition from InitialEmergency to NoEmergency
	transition from NoEmergency to Emergency when ExternalCommunication.emergency [ExternalCommunication.emergency::isOccurred]
	transition from Emergency to NoEmergency when ExternalCommunication.emergency [!ExternalCommunication.emergency::isOccurred]
	
	region AlignmentRegion {
		initial InitialAlignment
		state Aligned
		state Unaligned
//		{
//			entry / set tooLateCloseWhenUnaligned := TOO_LATE_CLOSED_WHEN_UNALIGNED s;
//		}
	}
	transition from InitialAlignment to Aligned
	transition from Aligned to Unaligned when ExternalCommunication.alignment [!ExternalCommunication.alignment::isAligned]
	transition from Unaligned to Aligned when ExternalCommunication.alignment [ExternalCommunication.alignment::isAligned]
//	transition from Unaligned to Unaligned when timeout tooLateCloseWhenUnaligned / if (!closedSentWhenUnaligned) tooLateClosedWhenUnaligned := true;
	
	region MovementRegion {
		initial InitialMovement
		state Still
		state InMotion
	}
	transition from InitialMovement to Still
	transition from Still to InMotion when ExternalCommunication.movement [ExternalCommunication.movement::isMoving]
	transition from InMotion to Still when ExternalCommunication.movement [!ExternalCommunication.movement::isMoving]
	
	region ControlRegion {
		initial InitialControl
		state Control
		merge OpenDoor
		merge CloseDoor
	}
	transition from InitialControl to Control
	// Consider priority between these transitions
	// Open
	// SC-1
	transition from Control to OpenDoor when cycle [
//			!(in-state(DoorStateRegion.Opening) or in-state(DoorStateRegion.Open)) and // Needed? // Discarded for continuous communication with the environment statechart (event-driven execution)
			in-state(EmergencyRegion.Emergency)]
	// SC-3
	transition from Control to CloseDoor when cycle [ // Self-loop: needed? (check closing logic) -- Set to close
			in-state(MovementRegion.InMotion)]
//	// SC-4
	transition from Control to CloseDoor when cycle [ // Self-loop: needed? (check closing logic) -- Set to close
			in-state(AlignmentRegion.Unaligned)]
	// SC-2
	transition from Control to OpenDoor when cycle [
//			!(in-state(DoorStateRegion.Opening) or in-state(DoorStateRegion.Open)) and // Needed?
			in-state(PresenceRegion.PersonInDoorway)]
	
	transition from OpenDoor to Control / raise ControlActions.controlDoor(ControlAction::OPEN);
	
	// Close
	// SC-7
	transition from Control to Control when cycle [ // Self-loop: conflict with open
			in-state(PresenceRegion.PersonInDoorway)]
	// SC-8
	transition from Control to Control when cycle [ // Self-loop: conflict with open
			in-state(EmergencyRegion.Emergency)]
	// SC-* We close after a timeout
	transition from Control to CloseDoor when timeout openTime [in-state(DoorStateRegion.Open)]
	 // SC-* Else we close
	transition from Control to CloseDoor when cycle
//			[!(in-state(DoorStateRegion.Closing) or in-state(DoorStateRegion.Closed))] // Needed?
	
	transition from CloseDoor to Control / raise ControlActions.controlDoor(ControlAction::CLOSE);
	
//////////////////////////
//	region DoorActuatorRegion {
//		initial InitialDoorActuator
//		state IdleDoorActuator
//	}
//	transition from InitialDoorActuator to IdleDoorActuator
//	
//	region DoorStateSensorRegion {
//		initial InitialDoorStateSensor
//		state IdleDoorStateSensor
//	}
//	transition from InitialDoorStateSensor to IdleDoorStateSensor
//	
//	region PresenceSensorRegion {
//		initial InitialPresenceSensor
//		state IdlePresenceSensor
//	}
//	transition from InitialPresenceSensor to IdlePresenceSensor
//	
//	region DoorRegion {
//		initial InitialDoor
//		state IdleDoor
//	}
//	transition from InitialDoor to IdleDoor
	
}
